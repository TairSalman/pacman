<style>
    body{
        margin: 0;
        background-color: black;
    }
</style>
<!DOCTYPE html>
<html>
    
    <head></head>
    
    <body>
        <p style="color: white; font-family: sans-serif;">
        <span>Player Name: <span id="playerName"></span>    
        </span>
        </p>
        <p style="color: white; font-family: sans-serif;">
        <span>Time: <span id="timeEL">0</span>    
        </span>
        </p>
        <p style="color: white; font-family: sans-serif;">
        <span>Score: <span id="scoreEL">0</span>    
        </span>
        </p>
        <p style="color: white; font-family: sans-serif;">
        <span>Health: <span id="healthEL">0</span>    
        </span>
        </p>
        <canvas id="canvas" height="600" width="600"></canvas>
		
        <script type="text/javascript">
            const scoreEL = document.getElementById('scoreEL')
            var c = canvas.getContext("2d");

            class Boundary{
                static height = 40
                static width = 40
                constructor({ position, image }) {
                    this.position = position
                    this.width = 40
                    this.height = 40
                    this.image = image
                }

                draw() {
                    //c.fillStyle = "blue"
                    //c.fillRect(this.position.x, this.position.y, this.width, this.height)
                    c.drawImage(this.image, this.position.x, this.position.y)
                }
            }

            class Player{
                constructor({ position, velocity }) {
                    this.position = position
                    this.velocity = velocity
                    this.radius = 15
                    this.speed = 1.5
                    this.radians = 0.75
                    this.openRate = 0.04
                    this.rotation = 0
                }

                draw() {
                    c.save()
                    c.translate(this.position.x, this.position.y)
                    c.rotate(this.rotation)
                    c.translate(-this.position.x, -this.position.y)

                    c.beginPath()
                    c.arc(this.position.x, this.position.y, this.radius, this.radians, Math.PI*2 - this.radians)
                    c.lineTo(this.position.x, this.position.y)
                    c.fillStyle = 'yellow'
                    c.fill()
                    c.closePath()
                    c.restore()
                }

                update(){
                    this.draw()
                    this.position.x += this.velocity.x
                    this.position.y += this.velocity.y

                    if(this.radians < 0 || this.radians > 0.75) this.openRate = -this.openRate

                    this.radians += this.openRate
                }
            }

            class Pellet{
                constructor({ position, radius = 3, color = 'white', score = 5}) {
                    this.position = position
                    this.radius = radius
                    this.color = color
                    this.score = score
                    //this.image=image
                }

                draw() {
                    c.beginPath()
                    c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI*2)
                    c.fillStyle = this.color
                    c.fill()
                    c.closePath()
                    //c.drawImage(this.image, this.position.x - Boundary.width/2, this.position.y- Boundary.height/2)
                }

            }

            class PowerUp{
                constructor({ position, radius = 5, color = 'yellow', score = 5, image = NaN, type='time' }) {
                    this.position = position
                    this.radius = radius
                    this.color = color
                    this.score = score
                    this.image = image
                    this.type = type
                }

                draw() {
                    c.beginPath()
                    c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI*2)
                    c.fillStyle = this.color
                    c.fill()
                    c.closePath()
                    
                    c.drawImage(this.image, this.position.x - Boundary.width/2, this.position.y- Boundary.height/2)
                }

            }

            class Ghost{
                static speed = 1
                constructor({ position, velocity, color='red', friend = false, radius=15 }) {
                    this.position = position
                    this.velocity = velocity
                    this.radius = radius
                    this.color = color
                    this.prevCollisions = []
                    this.speed = 1
                    this.friend = friend
                }

                draw() {
                    c.beginPath()
                    c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI*2)
                    c.fillStyle = this.color
                    c.fill()
                    c.closePath()
                }

                update(){
                    this.draw()
                    this.position.x += this.velocity.x
                    this.position.y += this.velocity.y
                }
            }
            function startGame(ghostsAmount,pelletsAmount,gameTime,name,up='ArrowUp',down='ArrowDown',right='ArrowRight',left='ArrowLeft',color5,color10,color25,random=false) 
            { 

            if(random==false)
            {
            monstersAmount = ghostsAmount //settings 1 - 4
            pelletsAmount = pelletsAmount//settings 50 - 90
            var timeLeft = gameTime; //settings 60+ seconds
            up = up//'ArrowUp'
            down = down//'ArrowDown'
            right = right//'ArrowRight'
            left = left//'ArrowLeft'
            colorBall5 = color5
            colorBall10 = color10
            colorBall25 = color25
            playerName.innerHTML=name
            }
            else{
            colors = ["Blue ", "Green", "Red", "Orange", "Violet", "Indigo", "Yellow", "White","Silver","lime","fuchsia","teal","aqua","aquamarine","azure","bisque"];
            monstersAmount = Math.floor(Math.random() * 4) + 1; //settings 1 - 4
            pelletsAmount = Math.floor(Math.random() * 50) + 40;//settings 50 - 90
            var timeLeft = Math.floor(Math.random() * 60) + 60; //settings 60+ seconds
            up = 'ArrowUp'
            down = 'ArrowDown'
            right = 'ArrowRight'
            left = 'ArrowLeft' 
            colorBall5 = colors[Math.floor(Math.random()*colors.length)];
            colorBall10 = colors[Math.floor(Math.random()*colors.length)];
            colorBall25 = colors[Math.floor(Math.random()*colors.length)];
            playerName.innerHTML=name
            }

            var timerAudio
            function playAudio() {
            let audio = new Audio('./background_music.mp3');
            audio.loop=true
            audio.play()            
            }
            addEventListener('keydown', playAudio, {once : true});
            
            var timer; 
            lose=false
            pelletCheck = 0
            currentMonstersAmount = 0
            currentPelletsAmount = 0
            health=5
            
            function updateTimer() {
            timeLeft = timeLeft - 1;
            if(timeLeft >= 0 && !lose)
                timeEL.innerHTML=timeLeft
            else {
                lose=true
                console.log('lose')
            }
            }
            timer = setInterval(updateTimer, 1000);
            updateTimer();

            randomPositionX = []
            randomPositionY = []
            const pellets = []
            const boundaries = []
            const ghosts = []
            const PowerUps = []


            const keys = {
                ArrowUp: {
                    pressed: false
                },
                ArrowLeft: {
                    pressed: false
                },
                ArrowDown: {
                    pressed: false
                },
                ArrowRight: {
                    pressed: false
                },
            }

            let lastKey = ''
            let score = 0

            const map = [
            ['1', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '2'],
            ['|', 'm', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'm', '|'],
            ['|', '.', 'b', '.', 'b', '.', '[', '7', ']', '.', 'b', '.', 'b', '.', '|'],
            ['|', '.', '.', '.', '.', '.', '.', '_', '.', '.', '.', '.', '.', '.', '|'],
            ['|', '.', 'b', '.', '[', ']', '.', 'p', '.', '[', ']', '.', 'b', '.', '|'],
            ['|', '.', '.', '.', '.', '.', '.', '^', '.', '.', '.', '.', '.', '.', '|'],
            ['|', '.', 'b', '.', 'b', 'h', '[', '+', ']', 'h', 'b', '.', 'b', '.', '|'],
            ['|', '.', '.', '.', '.', '.', '.', '_', '.', '.', '.', '.', '.', '.', '|'],
            ['|', '.', 'b', '.', '[', ']', '.', 'p', '.', '[', ']', '.', 'b', '.', '|'],
            ['|', '.', '.', '.', '.', '.', '.', '^', '.', '.', '.', '.', '.', '.', '|'],
            ['|', '.', 'b', '.', 'b', '.', '[', '5', ']', '.', 'b', '.', 'b', '.', '|'],
            ['|', 'm', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'm', '|'],
            ['4', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '3']

            ]

            function createImage(src){
                const image = new Image()
                image.src = src 
                return image
            }

            map.forEach((row, i) => {
                row.forEach((Symbol,j) => {
                    switch(Symbol) {
                        case '-':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: Boundary.width * j,
                                y: Boundary.height * i
                                },
                                image: createImage('./img/pipeHorizontal.png')
                            })
                            )
                            break
                        case '|':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: Boundary.width * j,
                                y: Boundary.height * i
                                },
                                image: createImage('./img/pipeVertical.png')
                            })
                            )
                            break
                        case '1':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: Boundary.width * j,
                                y: Boundary.height * i
                                },
                                image: createImage('./img/pipeCorner1.png')
                            })
                            )
                            break
                        case '2':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: Boundary.width * j,
                                y: Boundary.height * i
                                },
                                image: createImage('./img/pipeCorner2.png')
                            })
                            )
                            break
                        case '3':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: Boundary.width * j,
                                y: Boundary.height * i
                                },
                                image: createImage('./img/pipeCorner3.png')
                            })
                            )
                            break
                        case '4':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: Boundary.width * j,
                                y: Boundary.height * i
                                },
                                image: createImage('./img/pipeCorner4.png')
                            })
                            )
                            break
                        case 'b':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: Boundary.width * j,
                                y: Boundary.height * i
                                },
                                image: createImage('./img/block.png')
                            })
                            )
                            break
                        case '[':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: j * Boundary.width,
                                y: i * Boundary.height
                                },
                                image: createImage('./img/capLeft.png')
                            })
                            )
                            break
                        case ']':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: j * Boundary.width,
                                y: i * Boundary.height
                                },
                                image: createImage('./img/capRight.png')
                            })
                            )
                            break
                        case '_':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: j * Boundary.width,
                                y: i * Boundary.height
                                },
                                image: createImage('./img/capBottom.png')
                            })
                            )
                            break
                        case '^':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: j * Boundary.width,
                                y: i * Boundary.height
                                },
                                image: createImage('./img/capTop.png')
                            })
                            )
                            break
                        case '+':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: j * Boundary.width,
                                y: i * Boundary.height
                                },
                                image: createImage('./img/pipeCross.png')
                            })
                            )
                            break
                        case '5':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: j * Boundary.width,
                                y: i * Boundary.height
                                },
                                color: 'blue',
                                image: createImage('./img/pipeConnectorTop.png')
                            })
                            )
                            break
                        case '6':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: j * Boundary.width,
                                y: i * Boundary.height
                                },
                                color: 'blue',
                                image: createImage('./img/pipeConnectorRight.png')
                            })
                            )
                            break
                        case '7':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: j * Boundary.width,
                                y: i * Boundary.height
                                },
                                color: 'blue',
                                image: createImage('./img/pipeConnectorBottom.png')
                            })
                            )
                            break
                        case '8':
                            boundaries.push(
                            new Boundary({
                                position: {
                                x: j * Boundary.width,
                                y: i * Boundary.height
                                },
                                //image: createImage('./img/pipeConnectorLeft.png')
                            })
                            )
                            break
                        case '.':
                            pelletCheck+=pelletsAmount/102 //106 max pellets
                            if(currentPelletsAmount<pelletCheck && currentPelletsAmount < pelletsAmount){

                            randomPellet = Math.floor(Math.random() * 10);
                            if(randomPellet < 1){
                                pellets.push(
                                new Pellet({
                                    position: {
                                    x: j * Boundary.width + Boundary.width / 2,
                                    y: i * Boundary.height + Boundary.height / 2
                                    },
                                    radius: 5,
                                    color: colorBall25,
                                    score: 25,
                                    //image: createImage('./img/gem_purple.png')
                                })
                                )
                            }
                            else if((randomPellet < 5 && randomPellet > 0)){
                                pellets.push(
                                new Pellet({
                                    position: {
                                    x: j * Boundary.width + Boundary.width / 2,
                                    y: i * Boundary.height + Boundary.height / 2
                                    },
                                    radius: 4,
                                    color: colorBall10,
                                    score: 10,
                                    //image: createImage('./img/gem_green.png')
                                })
                                )
                            }
                            else{

                                pellets.push(
                                new Pellet({
                                    position: {
                                    x: j * Boundary.width + Boundary.width / 2,
                                    y: i * Boundary.height + Boundary.height / 2
                                    },
                                    color: colorBall5
                                    //image: createImage('./img/gem_blue.png')
                                })
                                )        
                            }
                            
                            currentPelletsAmount++
                        }
                            randomPositionX.push(j);
                            randomPositionY.push(i);
                        
                            break

                        case 'm': //monsters
    
                            if(monstersAmount > currentMonstersAmount && currentMonstersAmount%2==1)
                            {
                            ghosts.push(
                            new Ghost({
                                position: {
                                x: j * Boundary.width + Boundary.width/2,
                                y: i * Boundary.height + Boundary.height/2
                                },
                                velocity: {
                                    x: -Ghost.speed,
                                    y: 0
                                }
                      
                            })
                            )
                            currentMonstersAmount = currentMonstersAmount + 1
                            }
                            else if(monstersAmount > currentMonstersAmount){
                            ghosts.push(
                            new Ghost({
                                position: {
                                x: j * Boundary.width + Boundary.width/2,
                                y: i * Boundary.height + Boundary.height/2
                                },
                                velocity: {
                                    x: Ghost.speed,
                                    y: 0
                                },
                                color: 'blue'
                            })
                            )
                            currentMonstersAmount = currentMonstersAmount + 1
                            }
                            break

                            case 'p':
                            PowerUps.push(
                            new PowerUp({
                                position: {
                                x: j * Boundary.width + Boundary.width/2,
                                y: i * Boundary.height + Boundary.height/2
                                },
                                image: createImage('./img/timer.png')
                            })
                            )
                            break
                            case 'h':
                            PowerUps.push(
                            new PowerUp({
                                position: {
                                x: j * Boundary.width + Boundary.width/2,
                                y: i * Boundary.height + Boundary.height/2
                                },
                                type: 'health',
                                image: createImage('./img/heart.png')
                            })
                            )
                            break
                    }
                })
                
            })

            
            randomPos=Math.floor(Math.random() * randomPositionX.length) //random pos for ghost friend
            if(randomPositionX[randomPos]+1==randomPositionX[randomPos+1]){
            friendSpeedX = 1
            friendSpeedY = 0
            }
            else if(randomPositionX[randomPos-1]==randomPositionX[randomPos]-1){
            friendSpeedX = -1
            friendSpeedY = 0
            }
            else if(randomPositionY[randomPos]+1==randomPositionY[randomPos+1]){
            friendSpeedY = 1
            friendSpeedX = 0
            }
            else{
            friendSpeedY = -1
            friendSpeedX = 0
            }
            ghosts.push(
            new Ghost({
                position: {
                x: randomPositionX[randomPos] * Boundary.width + Boundary.width/2,
                y: randomPositionY[randomPos] * Boundary.height + Boundary.height/2
                },
                velocity: {
                    x: friendSpeedX,
                    y: friendSpeedY
                 },
                color: 'pink',
                friend: true,
                radius: 10
            })
            )


            randomPos=Math.floor(Math.random() * randomPositionX.length) //random pos for player
            const player = new Player({
                
                position:{
                    
                    x:Boundary.width*randomPositionX[randomPos] + Boundary.width/2,
                    y:Boundary.height*randomPositionY[randomPos] + Boundary.height/2
            },
                velocity:{
                    x:0,
                    y:0
                }
            })

            function circleCollideWithRectangle({circle,rectangle}) {
                const padding = Boundary.width/2 - circle.radius - 1
                return (circle.position.y - circle.radius + circle.velocity.y <= rectangle.position.y + rectangle.height + padding && 
                circle.position.x + circle.radius + circle.velocity.x >= rectangle.position.x - padding &&
                circle.position.y + circle.radius + circle.velocity.y >= rectangle.position.y - padding  &&   
                circle.position.x - circle.radius + circle.velocity.x <= rectangle.position.x + rectangle.width + padding)
            }


            function animate() {
                animationId = requestAnimationFrame(animate)
                c.clearRect(0, 0, canvas.width, canvas.height)
                healthEL.innerHTML=health

                if (keys.ArrowUp.pressed && lastKey == 'ArrowUp') {
                    for(let i = 0; i < boundaries.length; i++){
                        const boundary = boundaries[i]
                        if(circleCollideWithRectangle({circle: {...player, velocity: { x: 0, y: -player.speed}}, rectangle: boundary})) 
                        {
                            player.velocity.y = 0 
                            break
                        }   
                        else
                        {player.velocity.y = -player.speed}  
                    } 
                

                } else if (keys.ArrowLeft.pressed & lastKey == 'ArrowLeft') {
                    for(let i = 0; i < boundaries.length; i++){
                        const boundary = boundaries[i]
                        if(circleCollideWithRectangle({circle: {...player, velocity: { x: -player.speed, y: 0}}, rectangle: boundary})) 
                        {
                            player.velocity.x = 0
                            break
                        }   
                        else
                        {player.velocity.x = -player.speed}  
                    } 
                } else if (keys.ArrowDown.pressed & lastKey == 'ArrowDown') {
                    for(let i = 0; i < boundaries.length; i++){
                        const boundary = boundaries[i]
                        if(circleCollideWithRectangle({circle: {...player, velocity: { x: 0, y: player.speed}}, rectangle: boundary})) 
                        {
                            player.velocity.y = 0
                            break
                        }   
                        else
                        {player.velocity.y = player.speed}  
                    }
                } else if (keys.ArrowRight.pressed & lastKey == 'ArrowRight') {
                    for(let i = 0; i < boundaries.length; i++){
                        const boundary = boundaries[i]
                        if(circleCollideWithRectangle({circle: {...player, velocity: { x: player.speed, y: 0}}, rectangle: boundary})) 
                        {
                            player.velocity.x = 0
                            break
                        }   
                        else
                        {player.velocity.x = player.speed}  
                    }
                }

                for(let i = PowerUps.length - 1; 0 <= i; i--){
                    const PowerUp = PowerUps[i]
                    PowerUp.draw()
                    if( Math.hypot(PowerUp.position.x - player.position.x, PowerUp.position.y - player.position.y) < PowerUp.radius + player.radius && PowerUp.type=='time')
                    {
                        PowerUps.splice(i,1)
                        timeLeft+=10
                        timeEL.innerHTML=timeLeft
                    }
                    else if( Math.hypot(PowerUp.position.x - player.position.x, PowerUp.position.y - player.position.y) < PowerUp.radius + player.radius && PowerUp.type=='health')
                    {
                        PowerUps.splice(i,1)
                        health+=1
                        healthEL.innerHTML=health
                    }

                }
                
                for(let i = pellets.length - 1; 0 <= i; i--){
                    const pellet = pellets[i]
                    pellet.draw()

                    if( Math.hypot(pellet.position.x - player.position.x, pellet.position.y - player.position.y) < pellet.radius + player.radius)
                    {
                            pellets.splice(i,1)
                            score += pellet.score
                            scoreEL.innerHTML = score
                    }
                }
                
                //win
                console.log(pellets.length)
                if (pellets.length === 0){
                    console.log('win')
                    cancelAnimationFrame(animationId)
                }
                

                boundaries.forEach((boundary) => {
                    boundary.draw()

                    if(circleCollideWithRectangle({circle: player, rectangle: boundary}))
                    {
                        console.log('collide')
                        player.velocity.x = 0
                        player.velocity.y = 0
                    }

                })

                player.update()



                ghosts.forEach(ghost => {
                    ghost.update()
                    
                    if( Math.hypot(ghost.position.x - player.position.x, ghost.position.y - player.position.y) < ghost.radius + player.radius && ghost.friend==false)
                    {
                        if(ghost.color=='red')
                        {
                            health-=2
                        }
                        else
                            health-=1
                        
                        healthEL.innerHTML=health
                        if(health<=0){
                            lose=true
                            cancelAnimationFrame(animationId)
                        }
                       score-=10
                       scoreEL.innerHTML = score
                       
                       randomPos=Math.floor(Math.random() * randomPositionX.length) //random pos for player

                       player.position.x = Boundary.width*randomPositionX[randomPos] + Boundary.width/2,
                       player.position.y = Boundary.width*randomPositionY[randomPos] + Boundary.width/2
                    }
                    else if( Math.hypot(ghost.position.x - player.position.x, ghost.position.y - player.position.y) < ghost.radius + player.radius && ghost.friend==true)
                    {
                        ghosts.pop()
                        score+=50
                        scoreEL.innerHTML = score
                    }

                    const collisions = []
                    boundaries.forEach(boundary => {

                        if(!collisions.includes('right') && circleCollideWithRectangle({circle: {...ghost, velocity: { x: ghost.speed, y: 0}}, rectangle: boundary})) 
                        {
                            collisions.push('right')
                            
                        }
                        if(!collisions.includes('left') && circleCollideWithRectangle({circle: {...ghost, velocity: { x: -ghost.speed, y: 0}}, rectangle: boundary})) 
                        {
                            collisions.push('left')
                            
                        }  
                        if(!collisions.includes('up') && circleCollideWithRectangle({circle: {...ghost, velocity: { x: 0, y: -ghost.speed}}, rectangle: boundary})) 
                        {
                            collisions.push('up')
                            
                        }  
                        if(!collisions.includes('down') && circleCollideWithRectangle({circle: {...ghost, velocity: { x: 0, y: ghost.speed}}, rectangle: boundary})) 
                        {
                            collisions.push('down')
                            
                        }     
                      
                    })
                    if(collisions.length > ghost.prevCollisions.length){
                    ghost.prevCollisions = collisions
                    }

                    if(JSON.stringify(collisions) !== JSON.stringify(ghost.prevCollisions)){

                        if(ghost.velocity.x > 0) ghost.prevCollisions.push('right')
                        else if(ghost.velocity.x < 0) ghost.prevCollisions.push('left')
                        else if(ghost.velocity.y < 0) ghost.prevCollisions.push('up')
                        else if(ghost.velocity.y > 0) ghost.prevCollisions.push('down')

                        const pathWays = ghost.prevCollisions.filter(collision => {
                            return !collisions.includes(collision)
                        })


                        const direction = pathWays[Math.floor(Math.random() * pathWays.length)]

                        switch (direction) {
                            case 'down':
                                ghost.velocity.y = ghost.speed
                                ghost.velocity.x = 0
                                break
                            case 'up':
                                ghost.velocity.y = -ghost.speed
                                ghost.velocity.x = 0
                                break
                            case 'right':
                                ghost.velocity.y = 0
                                ghost.velocity.x = ghost.speed
                                break
                            case 'left':
                                ghost.velocity.y = 0
                                ghost.velocity.x = -ghost.speed
                                break
                        }

                        ghost.prevCollisions = []
                    }


                })
            if (player.velocity.x > 0) player.rotation = 0
            else if (player.velocity.x < 0) player.rotation = Math.PI
            else if (player.velocity.y > 0) player.rotation = Math.PI / 2
            else if (player.velocity.y < 0) player.rotation = Math.PI * 1.5

            }



            animate()

            addEventListener('keydown', ({key}) =>{
                switch (key){
                    case up:
                        keys.ArrowUp.pressed = true
                        lastKey = 'ArrowUp'
                        break
                    case left:
                        keys.ArrowLeft.pressed = true
                        lastKey = 'ArrowLeft'
                        break
                    case down:
                        keys.ArrowDown.pressed = true
                        lastKey = 'ArrowDown'
                        break
                    case right:
                        keys.ArrowRight.pressed = true
                        lastKey = 'ArrowRight'
                        break
                }
            })


            addEventListener('keyup', ({key}) =>{
                switch (key){
                    case 'ArrowUp':
                        keys.ArrowUp.pressed = false
                        break
                    case 'ArrowLeft':
                        keys.ArrowLeft.pressed = false
                        break
                    case 'ArrowDown':
                        keys.ArrowDown.pressed = false
                        break
                    case 'ArrowRight':
                        keys.ArrowRight.pressed = false
                        break
                }
            })

        }

        startGame(4,90,120,"Raz","ArrowUp","ArrowDown","ArrowRight","ArrowLeft",'red','white','red',true)
        </script>
        

    </body>

</html>
